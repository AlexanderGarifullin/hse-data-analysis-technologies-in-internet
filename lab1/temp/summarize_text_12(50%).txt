C++ (читается си-плюс-плюс[2][3]) — компилируемый, статически типизированный язык программирования общего назначения. Язык имеет богатую стандартную библиотеку, которая включает в себя распространённые контейнеры и алгоритмы, ввод-вывод, регулярные выражения, поддержку многопоточности и другие возможности. C++ сочетает свойства как высокоуровневых, так и низкоуровневых языков[4][5]. C++ широко используется для разработки программного обеспечения, являясь одним из самых популярных языков программирования[мнения 1][мнения 2]. Существует множество реализаций языка C++, как бесплатных, так и коммерческих и для различных платформ. Например, на платформе x86 это GCC, Clang, Visual C++, Intel C++ Compiler, Embarcadero (Borland) C++ Builder и другие. C++ оказал огромное влияние на другие языки программирования, в первую очередь на Java и C#. Синтаксис C++ унаследован от языка Си. Тем не менее, C++ не является в строгом смысле надмножеством Си: множество программ, которые могут одинаково успешно транслироваться как компиляторами Си, так и компиляторами C++, довольно велико, но не включает все возможные программы на Си. Создание
Язык возник в начале 1980-х годов, когда сотрудник фирмы Bell Labs Бьёрн Страуструп придумал ряд усовершенствований к языку Си под собственные нужды[7]. Так, язык Симула имеет такие возможности, которые были бы очень полезны для разработки большого программного обеспечения, но работает слишком медленно, а язык BCPL достаточно быстр, но слишком близок к языкам низкого уровня и не подходит для разработки большого программного обеспечения. Вспомнив опыт своей диссертации, Страуструп решил дополнить язык C (преемник BCPL) возможностями, имевшимися в языке Симула. Язык Си, будучи базовым языком системы Unix, на которой работали компьютеры Bell, является быстрым, многофункциональным и переносимым. Разрабатывая «Си с классами», Страуструп написал программу cfront — транслятор, перерабатывающий исходный код своего языка в исходный код простого Си. Новый язык неожиданно для автора приобрёл большую популярность среди коллег и вскоре Страуструп уже не мог лично поддерживать его, отвечая на тысячи вопросов. К 1983 году в язык были добавлены новые возможности, такие как виртуальные функции, перегрузка функций и операторов, ссылки, константы, пользовательский контроль над управлением свободной памятью, улучшенная проверка типов и новый стиль комментариев (//). Получившийся язык уже перестал быть просто дополненной версией классического C и был переименован из C с классами в «C++». До начала официальной стандартизации язык развивался в основном силами Страуструпа в ответ на запросы программистского сообщества. Функцию стандартных описаний языка выполняли написанные Страуструпом печатные работы по C++ (описание языка, справочное руководство и так далее). Лишь в 1998 году был ратифицирован международный стандарт языка C++: ISO/IEC 14882:1998 «Standard for the C++ Programming Language»; после принятия технических исправлений к стандарту в 2003 году — следующая версия этого стандарта — ISO/IEC 14882:2003[8]. Развитие и стандартизация языка
В 1985 году вышло первое издание «Языка программирования C++», обеспечивающее первое описание этого языка, что было чрезвычайно важно из-за отсутствия официального стандарта. В 1989 году состоялся выход C++ версии 2.0. В 1990 году вышло «Комментированное справочное руководство по C++», положенное впоследствии в основу стандарта. Стандартная библиотека C++ также развивалась вместе с ним. Первым добавлением к стандартной библиотеке C++ стали потоки ввода-вывода, обеспечивающие средства для замены традиционных функций C printf и scanf. Официальная стандартизация языка началась в 1998 году, когда был опубликован стандарт языка ISO/IEC 14882:1998 (известный как C++98)[9], разработанный комитетом по стандартизации C++ (ISO/IEC JTC1/SC22/WG21 working group). Стандарт C++ не описывал способов именования объектов, некоторых деталей обработки исключений и других возможностей, связанных с деталями реализации, что делает несовместимым объектный код, созданный различными компиляторами. В 2003 году опубликован стандарт C++ ISO/IEC 14882:2003, где исправлены выявленные ошибки и недочёты предыдущей версии стандарта. Степень поддержки TR1 улучшается почти во всех поддерживаемых компиляторах языка C++. C++ продолжает развиваться, чтобы отвечать современным требованиям. Одна из групп, разрабатывающих язык C++ и направляющих комитету по стандартизации C++ предложения по его улучшению — это Boost, которая занимается, в том числе, совершенствованием возможностей языка путём добавления в него особенностей метапрограммирования. Никто не обладает правами на язык C++, он является свободным. В частности, технические доклады и технические характеристики публикуются, когда «видно будущее, но нет немедленной возможности соглашения для публикации международного стандарта.» До 2011 года было опубликовано три технических отчёта по C++: TR 19768: 2007 (также известный как C++, Технический отчёт 1) для расширений библиотеки в основном интегрирован в C++11, TR 29124: 2010 для специальных математических функций, и TR 24733: 2011 для десятичной арифметики с плавающей точкой. В марте 2016 года в России была создана рабочая группа РГ21 C++. Группа была организована для сбора предложений к стандарту C++, отправки их в комитет и защиты на общих собраниях Международной организации по стандартизации (ISO)[12]. Язык также не был назван D, поскольку «является расширением C и не пытается устранять проблемы путём удаления элементов C»[7]. Философия C++
В книге «Дизайн и эволюция C++»[13] Бьёрн Страуструп описывает принципы, которых он придерживался при проектировании C++. Эти принципы объясняют, почему C++ именно такой, какой он есть. Некоторые из них:

Получить универсальный язык со статическими типами данных, эффективностью и переносимостью языка C.
Непосредственно и всесторонне поддерживать множество стилей программирования, в том числе процедурное программирование, абстракцию данных, объектно-ориентированное программирование и обобщённое программирование. Максимально сохранить совместимость с C, тем самым делая возможным лёгкий переход от программирования на C.
Избежать разночтений между C и C++: любая конструкция, допустимая в обоих языках, должна в каждом из них обозначать одно и то же и приводить к одному и тому же поведению программы. Обзор языка
Стандарт C++ состоит из двух основных частей: описание ядра языка и описание стандартной библиотеки. Первое время язык развивался вне формальных рамок, спонтанно, по мере встававших перед ним задач. Эти номера версий кросс-компилятора распространялись и на сам язык, но применительно к настоящему времени речь о версиях языка C++ не ведут. Лишь в 1998 году язык стал стандартизированным. C++ поддерживает как комментарии в стиле C (/* комментарий */), так и однострочные (// вся оставшаяся часть строки является комментарием), где // обозначает начало комментария, а ближайший последующий символ новой строки, который не предварён символом \ (либо эквивалентным ему обозначением ? В отличие от С, где const обозначает только доступ на чтение, в C++ переменная с квалификатором const должна быть инициализирована. Пространство имён std содержит в себе стандартные библиотеки C++. Типы
В C++ доступны следующие встроенные типы. Типы C++ практически полностью повторяют типы данных в C:

символьные: char, wchar_t, char16_t и char32_t, в стандарте C++11 и char8_t в стандарте C++20);
целочисленные знаковые: signed char, short int, int, long int (и long long, в стандарте C++11);
целочисленные беззнаковые: unsigned char, unsigned short int, unsigned int, unsigned long int (и unsigned long long, в стандарте C++11);
с плавающей точкой: float, double, long double;
логический: bool, имеющий значения либо true, либо false. Язык ввёл понятие ссылок, а со стандарта C++11 — rvalue-ссылки и передаваемые ссылки (англ. Ссылка (C++))

C++ добавляет к C объектно-ориентированные возможности. В стандарте C++ под классом (class) подразумевается пользовательский тип, объявленный с использованием одного из ключевых слов class, struct или union, под структурой (structure) подразумевается класс, определённый через ключевое слово struct, и под объединением (union) подразумевается класс, определённый через ключевое слово union. Наследование
C++ поддерживает множественное наследование. Наследование от каждого класса может быть публичным, защищённым или закрытым:

Доступ члена базового класса/режим наследования	private-член	protected-член	public-член
private-наследование	недоступен	private	private
protected-наследование	недоступен	protected	protected
public-наследование	недоступен	protected	public
По умолчанию базовый класс наследуется как private. Чтобы избежать такого эффекта, если он нежелателен, C++ поддерживает концепцию виртуального наследования. также: Виртуальное наследование
Полиморфизм
C++ поддерживает динамический полиморфизм и параметрический полиморфизм. Полиморфным в C++ является тип, имеющий хотя бы один виртуальный метод. Пример иерархии:

class Figure
{
public:
    virtual void Draw() = 0; // чистый виртуальный метод
    virtual ~Figure();       // при наличии хотя бы одного виртуального метода деструктор следует сделать виртуальным
};

class Square : public Figure
{
public:
    void Draw() override;
};

class Circle : public Figure
{
public:
    void Draw() override;
};
Здесь класс Figure является абстрактным (и, даже, интерфейсным), так как метод Draw не определён. Инкапсуляция
Инкапсуляция в C++ реализуется через указание уровня доступа к членам класса: они бывают публичными (открытыми, public), защищёнными (protected) и приватными (закрытыми, private). В C++ структуры формально отличаются от классов лишь тем, что по умолчанию уровень доступа к членам класса и тип наследования у структуры публичные, а у класса — приватные. Четыре важных ограничения, накладываемых на отношения дружественности в C++:

Дружественность не транзитивна. Если A объявляет другом B, а B, в свою очередь, объявляет другом C, то C не становится автоматически другом для A. Для этого A должен явно объявить C своим другом. Если класс A объявляет другом класс B, то он не становится автоматически другом для B. Для этого должно существовать явное объявление дружественности A в классе B.
Дружественность не наследуется. Если класс A объявляет B другом, то B не становится автоматически другом для классов-потомков A. Каждый потомок, если это нужно, должен объявить B своим другом самостоятельно. Специальные функции
Класс по умолчанию может иметь шесть специальных функций: конструктор по умолчанию, конструктор копирования, конструктор перемещения, деструктор, оператор присваивания копированием, оператор присваивания перемещением. class Array {
public:
	Array() = default; // компилятор создаст конструктор по умолчанию сам
	Array(size_t _len) :
			len(_len) {
		val = new double[_len];
	}
	Array(const Array & a) = delete;  // конструктор копирования явно удалён
	Array(Array && a); // конструктор перемещения
	~Array() {
		delete[] val;
	}
	Array& operator=(const Array& rhs); // оператор присваивания копированием
	Array& operator=(Array&& rhs); // оператор присваивания перемещением
	double& operator[](size_t i) {
		return val[i];
	}
	const double& operator[](size_t i) const {
		return val[i];
	}

protected:
	std::size_t len = 0; // инициализация поля
	double* val {nullptr};
};
Конструктор вызывается для инициализации объекта (соответствующего типа) при его создании, а деструктор — для уничтожения объекта. Конструкторы в C++ не могут быть объявлены виртуальными, а деструкторы — могут, и обычно объявляются для всех полиморфных типов, чтобы гарантировать правильное уничтожение доступного по ссылке или указателю объекта независимо от того, какого типа ссылка или указатель. Шаблоны
Основная статья: Шаблоны C++
Шаблоны позволяют порождать функции и классы, параметризованные определённым типом или значением. Например, предыдущий класс мог бы реализовывать массив для любого типа данных:

template <typename T>
class Array {
    ...
    T& operator[](size_t i) {
		return val[i];
	}
protected:
	std::size_t len {0}; // инициализация поля
	T* val {nullptr};
};
Стандартная библиотека
Основная статья: Стандартная библиотека C++
Общая структура
Стандартная библиотека C++ включает в себя набор средств, которые должны быть доступны для любой реализации языка, чтобы обеспечить программистам удобное пользование языковыми средствами и создать базу для разработки как прикладных приложений самого широкого спектра, так и специализированных библиотек. Стандартная библиотека C++ включает в себя часть стандартной библиотеки Си. Стандарт C++ содержит нормативную ссылку на стандарт C от 1990 года и не определяет самостоятельно те функции стандартной библиотеки, которые заимствуются из стандартной библиотеки Си. Доступ к возможностям стандартной библиотеки C++ обеспечивается с помощью включения в программу (посредством директивы #include) соответствующих стандартных заголовочных файлов. Шаблоны строк в стиле C++. Шаблоны и вспомогательные классы для потоков ввода-вывода общего вида, строкового ввода-вывода, манипуляторы (средства управления форматом потокового ввода-вывода в стиле C++). Определения, используемые для поддержки национальных особенностей и форматов представления (дат, валют и так далее) в стиле C++ и в стиле Си. Изначально эта библиотека была отдельным продуктом и её аббревиатура расшифровывалась иначе, но потом она вошла в стандартную библиотеку C++ в качестве неотъемлемого элемента. В названии отражено то, что для реализации средств общего вида (контейнеров, строк, алгоритмов) использованы механизмы обобщённого программирования (шаблоны C++ — template). Реализации
STL до включения в стандарт C++ была сторонней разработкой, вначале — фирмы HP, а затем — SGI. Стандарт языка не называет её «STL», так как эта библиотека стала неотъемлемой частью языка, однако многие люди до сих пор используют это название, чтобы отличать её от остальной части стандартной библиотеки (потоки ввода-вывода (iostream), подраздел C и другие). Отличия от Си
Совместимость с Си
Основная статья: Несовместимость Си и C++
Выбор именно C в качестве базы для создания нового языка программирования объясняется тем, что язык C:
является многоцелевым, лаконичным и относительно низкоуровневым языком;
подходит для решения большинства системных задач;
исполняется везде и на всём;
стыкуется со средой программирования UNIX. Язык программирования C++. Раздел 1.6[16]
Несмотря на ряд известных недостатков языка Си, Страуструп пошёл на его использование в качестве основы, так как «в Си есть свои проблемы, но их имел бы и разработанный с нуля язык, а проблемы C нам известны». Кроме того, это позволило быстро получить прототип компилятора (cfront), который лишь выполнял трансляцию добавленных синтаксических элементов в оригинальный язык Си. По мере разработки C++ в него были включены другие средства, которые перекрывали возможности конструкций Си, в связи с чем неоднократно поднимался вопрос об отказе от совместимости языков путём удаления устаревших конструкций. Тем не менее, совместимость была сохранена из следующих соображений:

сохранение действующего кода, написанного изначально на C и прямо перенесённого в C++;
исключение необходимости переучивания программистов, ранее изучавших C (им требуется только изучить новые средства C++);
исключение путаницы между языками при их совместном использовании («если два языка используются совместно, их различия должны быть или минимальными, или настолько большими, чтобы языки было невозможно перепутать»). Новые возможности
Логотип Викиучебника	Имеется викиучебник по теме «Си++»
Новые возможности C++ включают объявления в виде выражений, преобразования типов в виде функций, операторы new и delete, тип bool, ссылки, расширенное понятие константности, подставляемые функции, аргументы по умолчанию, переопределения, пространства имён, классы (включая и все связанные с классами возможности, такие как наследование, функции-члены, виртуальные функции, абстрактные классы и конструкторы), переопределения операторов, шаблоны, оператор ::, обработку исключений, динамическую идентификацию и многое другое. Язык C++ также во многих случаях строже относится к проверке типов, чем C.

В C++ появились комментарии в виде двойной косой черты (//), которые были в предшественнике C — языке BCPL. Некоторые особенности C++ позднее были перенесены в C, например, ключевые слова const и inline, объявления в циклах for и комментарии в стиле C++ (//). В более поздних реализациях C также были представлены возможности, которых нет в C++, например макросы va_arg и улучшенная работа с массивами-параметрами. C++ не включает в себя C
Несмотря на то, что большая часть кода C будет справедлива и для C++, C++ не является надмножеством C и не включает его в себя. Существует и такой верный для C код, который неверен для C++. Это отличает его от Objective C, ещё одного усовершенствования C для ООП, как раз являющегося надмножеством C.

Существуют и другие различия. Например, C++ не разрешает вызывать функцию main() внутри программы, в то время как в C это действие правомерно. Кроме того, C++ более строг в некоторых вопросах; например, он не допускает неявное приведение типов между несвязанными типами указателей и не разрешает использовать функции, которые ещё не объявлены. Например, на большинстве платформ следующая программа печатает «С», если компилируется компилятором C, и «C++» — если компилятором C++. Так происходит из-за того, что символьные константы в C (например, 'a') имеют тип int, а в C++ — тип char, а размеры этих типов обычно различаются. "C++" : "C");
    return 0;
}
Средства C, которых рекомендуется избегать
По замечанию Страуструпа, «чем лучше вы знаете C, тем труднее вам будет избежать программирования на C++ в стиле C, теряя при этом потенциальные преимущества C++». В связи с этим он даёт следующий набор рекомендаций для программистов на C, чтобы в полной мере воспользоваться преимуществами C++:

Не использовать макроопределения #define. Общие направления развития C++
По мнению автора языка Бьёрна Страуструпа[19][20][21], говоря о дальнейшем развитии и перспективах языка, можно выделить следующее:

В основном дальнейшее развитие языка будет идти по пути внесения дополнений в стандартную библиотеку. Изменения в ядре языка не должны приводить к снижению уже достигнутой эффективности C++. Базовыми направлениями развития C++ на ближайшее время является расширение возможностей и доработка средств обобщённого программирования, стандартизация механизмов параллельной обработки, а также доработка средств безопасного программирования, таких как различные проверки и безопасные преобразования типов, проверка условий и так далее. В целом C++ спроектирован и развивается как мультипарадигменный язык, впитывающий в себя различные методы и технологии программирования, но реализующий их на платформе, обеспечивающей высокую техническую эффективность. Поэтому в будущем не исключено добавление в язык средств функционального программирования, автоматической сборки мусора и других отсутствующих в нём сейчас механизмов. Хотя формально одним из принципов C++ остаётся сохранение совместимости с языком C, фактически группы по стандартизации этих языков не взаимодействуют, а вносимые ими изменения не только не коррелируют, но и нередко принципиально противоречат друг другу идеологически. Так, элементы, которые новые стандарты C добавляют в ядро, в стандарте C++ являются элементами стандартной библиотеки и в ядре вообще отсутствуют, например, динамические массивы, массивы с фиксированными границами, средства параллельной обработки. Так что практическая совместимость между C и C++ постепенно будет утрачиваться. Вслед за многими современными языками в C++ введена конструкция «цикл по коллекции» вида for (type &x: array) {...}. Сравнение с альтернативными языками
Известно несколько исследований, в которых была сделана попытка более или менее объективно сравнить несколько языков программирования, одним из которых является C++. В частности:

В научной статье «Haskell vs. Ada vs. C++ vs. Awk vs. …» Пауля Худака и Марка Джонса[22] даётся отчёт об исследовании ряда императивных и функциональных языков на решении модельной задачи быстрого прототипирования ГИС-системы военного назначения. В научной статье «DSL implementation in metaocaml, template haskell, and C++» четырёх авторов[23] проводится методичное исследование применения C++ и двух функциональных языков в роли базовых инструментов для языково-ориентированного программирования методом порождающего программирования. В работе Лутца Прехельта[24] рассмотрено семь языков (C, C++, Java, Perl, Python, Rexx и Tcl) в задаче написания простой программы преобразования телефонных номеров в слова по определённым правилам. В статье Дэвида Велера «Ada, C, C++, and Java vs. The Steelman»[25] приведено сопоставление языков Ада, C++, Си, Java с документом «Steelman[англ. Хотя этот документ сильно устарел и не учитывает многих существенных свойств современных языков, сравнение демонстрирует, что C++ по набору востребованных в отрасли возможностей не так уж сильно отличается от языков, которые можно считать его реальными конкурентами. Статья Мэтью Формента и Михаэля Гиллингса[26] описывает исследование[27] реализации на шести языках — C++, C, C#, Java, Perl, Python, — трёх специфичных алгоритмов, применяемых в биоинформатике: метод ближайших соседей, глобальное выравнивание последовательностей (Алгоритм Нидлмана — Вунша) и парсинг результатов BLAST. C++ и Ада
Язык Ада близок к C++ по набору возможностей и по сферам применения: это компилируемый структурный язык с Симула-подобным объектно-ориентированным дополнением (та же модель «Алгол с классами», что и в C++), статической типизацией, средствами обобщённого программирования, предназначенный для разработки крупных и сложных программных систем. В то же время он принципиально отличается по идеологии: в отличие от C++, Ада строилась на основе предварительно тщательно проработанных условий производителей сложного ПО с повышенными требованиями к надёжности, что наложило отпечаток на синтаксис и семантику языка. Прямых сравнений эффективности кодирования на Аде и C++ немного. В упомянутой выше статье[22] решение модельной задачи на Аде привело к получению кода примерно на 30 % меньшего по объёму (в строках), чем на C++. Хотя многие утверждения сторонников Ады спорны, а часть из них явно устарела, в целом можно заключить:

Синтаксис Ады гораздо строже, чем C++. Язык требует соблюдения дисциплины программирования, не поощряет «программистские трюки», стимулирует написание простого, логичного и легко понимаемого кода, удобного в сопровождении. В отличие от C++, Ада максимально типобезопасна. Указатели в Аде контролируются гораздо более строго, чем в C++, а адресная арифметика доступна только через отдельную системную библиотеку. Настраиваемые модули Ады по возможностям аналогичны шаблонам C++, но обеспечивают лучший контроль. Ада имеет встроенную в язык модульность и стандартизованную систему раздельной компиляции, тогда как C++ применяет включение текстовых файлов и внешние средства управления компиляцией и сборкой. В C++ всё это реализуется только на уровне библиотек. Хотя эти результаты не могут быть прямо перенесены на C++, но всё же представляют интерес с учётом того, что многие недостатки C++ унаследованы от Си. C++ и Java
Java не может считаться в полной мере заменой C++, она создана как безопасный язык с низким порогом вхождения для разработки прикладных пользовательских приложений с высокими показателями портируемости[30] и принципиально непригодна для некоторых типов приложений, которые разрабатываются на C++. Однако в пределах своей области Java составляет вполне реальную конкуренцию C++. В качестве преимуществ Java обычно называют:

Безопасность: отсутствие поддержки указателей и адресной арифметики, автоматическое управление памятью со сборкой мусора, встроенные средства, защищающие от распространённых ошибок программ C++, таких как переполнение буфера или выход за границы массива. Наличие разработанной системы модулей и раздельной компиляции, значительно более быстрой и менее подверженной ошибкам, чем препроцессор и ручная сборка C++. Объектная подсистема Java в значительно более высокой степени, чем C++, отвечает фундаментальному принципу ООП «всё — объект». Рефлексия значительно более развита, чем в C++ и позволяет реально определять и изменять структуру объектов во время работы программы. Эмпирическое исследование[24] не обнаружило существенной разницы в скорости разработки на C++ и на Java. Исследование[26] также показало, что представление о существенной разнице в скорости программ на этих языках не всегда верно: в двух из трёх тестов скорость работы приложений на Java и C++ оказалась сравнима. C++ и C
Оригинальный Си продолжает развиваться, на нём разрабатываются многие масштабные проекты: он является основным языком разработки операционных систем, на нём написаны игровые движки многих динамических игр и большое число прикладных приложений. Ряд специалистов утверждает, что замена Си на C++ не повышает эффективности разработки, но приводит к ненужному усложнению проекта, снижению надёжности и увеличению затрат на сопровождение. В частности:

По мнению Линуса Торвальдса, «C++ провоцирует на написание … значительного объёма кода, не имеющего принципиального значения с точки зрения функциональности программы»[мнения 3]. Поддержка ООП, шаблоны и STL не являются решающим преимуществом C++, так как всё, для чего они применяются, реализуемо и средствами Си. Автоматизация доступа к памяти в C++ увеличивает затраты памяти и замедляет работу программ. Использование исключений C++ вынуждает следовать RAII, приводит к росту исполняемых файлов, замедлению программ. Показательно, что стандарт кодирования на C++ компании Google прямо запрещает использование исключений[31]. Код на C++ сложнее для понимания и тестирования, его отладка затрудняется использованием сложных иерархий классов с наследованием поведения и шаблонов. К тому же в средах программирования на C++ больше ошибок, как в компиляторах, так и в библиотеках. Многие детали поведения кода стандартом C++ не специфицированы, что ухудшает переносимость и может являться причиной трудно обнаруживаемых ошибок. Квалифицированных программистов на Си существенно больше, чем на C++. Нет убедительных данных о преимуществе C++ перед Си ни по производительности программистов, ни по свойствам программ. Хотя есть исследования[32], утверждающие, что программисты на Си тратят около 30-40 % общего времени разработки (не считая отладки) на управление памятью, при сопоставлении общей производительности разработчиков[22] Си и C++ оказываются близки. В низкоуровневом программировании значительная часть новых возможностей C++ оказывается неприменимой из-за увеличения накладных расходов: виртуальные функции требуют динамического вычисления реального адреса (RVA), шаблоны приводят к раздуванию кода и ухудшению возможностей оптимизации, библиотека времени исполнения (RTL) очень велика, а отказ от неё лишает большинства возможностей C++ (хотя бы из-за недоступности операций new/delete). В результате программисту придётся ограничиться функционалом, унаследованным от Си, что делает бессмысленным применение C++:

… единственный способ иметь хороший, эффективный, низкоуровневый и портируемый C++ сводится к тому, чтобы ограничиться всеми теми вещами, которые элементарно доступны в Си. … когда эффективность является первостепенным требованием, «преимущества» C++ будут огромной ошибкой. — Линус Торвальдс,[33]
C++ и функциональные и скриптовые языки
В одном эксперименте[22] скриптовые и функциональные языки, в частности, Haskell, показали 2-3 кратный выигрыш во времени программирования и объёме кода по сравнению с программами на C++. С другой стороны, программы на C++ оказались во столько же раз быстрее. В исследовании Лутца Прехельта[24] по результатам обработки около 80 решений, написанных добровольцами, получены, в частности, следующие выводы:

Perl, Python, Rexx, Tcl обеспечили скорость разработки вдвое больше, чем C, C++ и Java, причём полученный код был также вдвое короче. Критика
О критике C++ в целом
Чаще всего критики не противопоставляют C++ какой-либо другой конкретный язык, а утверждают, что отказ от использования единственного языка, имеющего многочисленные недостатки, в пользу декомпозиции проекта на подзадачи, решаемые на различных, наиболее подходящих для них, языках, делает разработку существенно менее трудоёмкой при одновременном повышении показателей качества программирования[35][36]. По этой же причине критикуется сохранение совместимости с Си: если часть задачи требует низкоуровневых возможностей, разумнее выделить эту часть в отдельную подсистему и написать её на Си. В свою очередь, сторонники C++ заявляют, что устранение технических и организационных проблем межъязыкового взаимодействия за счёт использования одного универсального языка вместо нескольких специализированных важнее, чем потери от несовершенства этого универсального языка, то есть сама широта набора возможностей C++ является оправданием недостатков каждой отдельной возможности; в том числе недостатки, унаследованные от Си, оправданы преимуществами совместимости (см. Таким образом, одни и те же свойства C++ — объём, сложность, эклектичность и отсутствие конкретной целевой ниши применения — рассматривается сторонниками как «главное достоинство», а критиками — как «главный недостаток». Компонентное и объектно-ориентированное программирование
По мнению Алана Кэя, объектная модель «Алгол с классами», использованная в C++, уступает модели «всё — объект»[37], используемой в Objective-C, по общем объёму возможностей, показателям повторного использования кода, понимаемости, модифицируемости и тестируемости. Модель наследования C++ сложна, трудна в реализации и при этом провоцирует создание сложных иерархий с неестественными отношениями между классами (например, наследование вместо вложения). Высокая вязкость решений на C++ может требовать повторной разработки значительных частей проекта при необходимости внесения минимальных изменений на поздних стадиях разработки. Как отмечает Ян Джойнер[39], C++ ошибочно отождествляет инкапсуляцию (то есть помещение данных внутрь объектов и отделение реализации от интерфейса) и сокрытие реализации. Совпадение типов в C++ определяется на уровне идентификаторов, а не сигнатур. Как отмечает Линус Торвальдс[33], в C++ «код кажется абстрактным лишь до тех пор, пока не возникает необходимость его изменить». Критика C++ с позиций ООП приведена в работе[39]. Метапрограммирование
Порождающее метапрограммирование C++ основано на шаблонах и препроцессоре, оно трудоёмко и ограничено по возможностям. Система шаблонов C++ фактически является вариантом примитивного функционального языка программирования, исполняемого на этапе компиляции. Этот язык почти не пересекается с самим C++, из-за чего потенциал роста сложности абстракций оказывается ограниченным. Программы, использующие шаблоны C++, имеют крайне низкие показатели понимаемости и тестируемости, а само разворачивание шаблонов порождает неэффективный код, так как язык шаблонов не предоставляет никаких средств для оптимизации (см. Встраиваемые предметно-специфичные языки, реализуемые таким образом, всё равно требуют знания самого C++, что не обеспечивает полноценного разделения труда. Таким образом, возможности C++ по расширению возможностей самого C++ весьма ограничены[41][42]. Кроссплатформенность
Для написания портируемого кода на C++ требуется огромное мастерство и опыт, и «небрежные» коды на C++ с высокой вероятностью могут оказаться непортируемыми[43]. По мнению Линуса Торвальдса, для обеспечения на C++ портируемости, аналогичной Си, программист должен ограничиться возможностями C++, унаследованными от Си[33]. Отсутствие возможностей
Рефлексивное метапрограммирование
Интроспекция в C++ реализована отдельно от основной системы типов, что делает её практически бесполезной. Это препятствует применению C++ в большинстве подходов к реализации искусственного интеллекта. Функциональное программирование
Явная поддержка функционального программирования присутствует только в стандарте C++0x, ранее пробел устранялся библиотеками (Loki, Boost), использующими язык шаблонов, но их качество значительно уступают решениям, встроенным в функциональные языки[пояснения 1], как и качеству реализаций возможностей C++ (таких как ООП) посредством функциональных языков. Реализованные в C++ возможности ФП не дают возможности применения присущих функциональному программированию оптимизационных методик, а ограничиваются вызовами функциональных библиотек и реализацией отдельных методов. Избыточные и опасные возможности
Встроенные средства обхода ограничений
Язык содержит средства, позволяющие программисту нарушать заданную в конкретном случае дисциплину программирования. Они сохранены в C++ несмотря на то, что для решения всех задач, для которых они были предусмотрены в Си, в C++ были предоставлены более строгие и специализированные средства — шаблоны, перегрузка функций, inline-функции, пространства имён, более развитая типизация, расширение применения модификатора const, и др. Проблемы перегрузки
Принятые в C++ принципы перегрузки функций и операторов приводят к значительному дублированию кода. Перегрузка операторов, исходно предназначенная для введения так называемого «синтаксического сахара», в C++ поощряет бесконтрольное изменение поведения элементарных операций для различных типов. Это резко повышает риск ошибок, тем более что вводить новый синтаксис и изменять существующий (например, создавать новые операторы или менять приоритеты или ассоциативность) нельзя, хотя синтаксис стандартных операторов C++ адекватен семантике далеко не всех типов, которые может потребоваться ввести в программу. При этом некоторые интуитивно ожидаемые операции (подчистка динамических объектов в случае генерации исключений) в C++ не выполняются, а значительная часть перегруженных функций и операторов вызывается неявно (приведение типов, создание временных экземпляров классов и др.). Вычислительная эффективность
Результирующий объём исполнимого кода
Использование шаблонов C++ представляет собой параметрический полиморфизм на уровне исходного кода, но при трансляции он превращается в ситуативный (ad hoc) полиморфизм (то есть перегрузку функций), что приводит к существенному увеличению объёма машинного кода в сравнении с языками, имеющими истинно полиморфную систему типов (потомками ML). Другим решением могла бы быть стандартизованная ещё в 1998 году возможность экспорта шаблонов, но она доступна далеко не во всех компиляторах, так как её трудно реализовать[48][49][мнения 4] и для импорта библиотек шаблонов C++ в языки с существенно отличной от C++ семантикой она всё равно была бы бесполезна. Сторонники C++ оспаривают масштабы раздувания кода как преувеличенные[50], игнорируя даже тот факт, что в Си параметрический полиморфизм транслируется непосредственно, то есть без дублирования тел функций вообще. При этом сторонники C++ считают, что параметрический полиморфизм в Си опасен — то есть более опасен, чем переход от Си к C++ (противники C++ утверждают обратное — см. В результате реальная эффективность программ на C++ ограничивается имеющейся квалификацией программистов и вложенными в конкретный проект усилиями, и «небрежная» реализация может существенно уступать по эффективности «небрежным» реализациям на языках более высокого уровня, что подтверждается сравнительными испытаниями языков[34]. Это является существенным препятствием против применения C++ в индустрии data mining. Для автоматического управления памятью в C++ традиционно используются так называемые «умные указатели», ручное же управление памятью снижает эффективность самих программистов. Многочисленные реализации сборки мусора, таких, как статический вывод регионов, не применимы для C++-программ (точнее, это требует реализации поверх языка C++ интерпретатора нового языка, сильно отличающегося от C++ как большинством объективных свойств, так и общей идеологией) по причине необходимости прямого доступа к абстрактному синтаксическому дереву. Результативность
Соотнесение факторов результативности с затратами на разработку, а также общую культивируемую в сообществе программистов дисциплину и культуру программирования важно принимать во внимание заказчикам, выбирающим язык С++ (и, соответственно, предпочитающим этот язык разработчикам) для реализации задуманных ими проектов, а также людям, начинающим изучать программирование, особенно с намерением программировать для собственных нужд. Качество и культура программирования
Принцип C++ «не навязывать „хороший“ стиль программирования» противоречит промышленному подходу к программированию, в котором ведущую роль играют качество программного обеспечения и возможность сопровождения кода не только автором, и для которого предпочтительны языки, сводящие к минимуму влияние человеческого фактора, то есть как раз «навязывающие „хороший“ стиль программирования», хотя такие языки и могут иметь более высокий порог вхождения. Существует мнение, что предпочтение использования C++ (при возможности выбора альтернативных языков) отрицательно характеризует профессиональные качества программиста. В частности, Линус Торвальдс говорит, что использует положительное мнение кандидатов о C++ в качестве критерия отсева[мнения 3]:
C++ — кошмарный язык. Его делает ещё более кошмарным тот факт, что множество недостаточно грамотных программистов используют его… Откровенно говоря, даже если нет никаких причин для выбора Си, кроме того чтобы держать C++-программистов подальше — то одно это уже будет достаточно веским основанием для использования Си. …Я пришёл к выводу, что действительно предпочту выгнать любого, кто предпочтёт вести разработку проекта на C++, нежели на Си, чтобы этот человек не загубил проект, в который я вовлечён. В частности, хотя изначально обратная совместимость с Си была одним из базовых принципов C++, с 1999 года Си перестал быть подмножеством C++, так что отлаженный код на Си уже не может использоваться в проекте на C++ без изменений. Сложность ради самой сложности
C++ определяется его апологетами как «мощнейший» именно потому, что он изобилует опасными взаимно-противоречивыми возможностями. По мнению Эрика Реймонда, это делает язык сам по себе почвой для личного самоутверждения программистов, превращения процесса разработки в самоцель:

Программисты — это зачастую яркие люди, которые гордятся … своей способностью справляться со сложностями и ловко обращаться с абстракциями. — Эрик Реймонд в [51]
Саботаж
Отмечены случаи, когда нерадивые программисты, пользуясь сильной контекстной зависимостью C++ и отсутствием возможности отслеживания макроопределений компилятором, тормозили разработку проекта, написав одну-две лишних, корректных с точки зрения компилятора, строки кода, но внедрив за их счёт труднообнаружимую спонтанно проявляющуюся ошибку. Ненадёжность продукта
Неоправданное обилие побочных эффектов в сочетании с отсутствием контроля со стороны системы времени исполнения языка и слабой системой типов делает программы на C++ подверженными непредсказуемым фатальным сбоям (общеизвестные падения с сообщениями типа «Access violation», «Pure virtual function call» или «Программа выполнила недопустимую операцию и будет закрыта»), что исключает применение C++ при высоких требованиях к отказоустойчивости. Менеджмент проектов
Перечисленные выше факторы делают сложность менеджмента проектов на C++ одной из самых высоких в индустрии разработки ПО. Джеймс Коггинс, в течение четырёх лет ведущий колонку в The C++ Report, даёт такое объяснение:
 — Проблема в том, что программисты, работающие в ООП, экспериментировали с кровосмесительными приложениями и были нацелены на низкий уровень абстракции. К несчастью, строгая проверка типов, которая помогает программистам C++ избегать ошибок, одновременно затрудняет построение больших объектов из маленьких. — Ф. Брукс, Мифический человеко-месяц
Влияние и альтернативы
Единственным прямым потомком C++ является язык D, задуманный как переработка C++ для устранения наиболее очевидных его проблем. Авторы отказались от совместимости с Си, сохранив синтаксис и многие базовые принципы C++ и введя в язык возможности, характерные для новых языков. Использование D весьма ограничено, считать его реальным конкурентом C++ нельзя. Старейшим конкурентом C++ в задачах низкого уровня является Objective-C, также построенный по принципу объединения Си с объектной моделью, только объектная модель унаследована от Smalltalk. Одной из первых альтернатив C++ в прикладном программировании стал язык Java. Его часто ошибочно считают прямым потомком C++; в действительности семантика Java унаследована от языка Модула-2, и основы семантики C++ в Java не прослеживаются. Учитывая это, а также генеалогию языков (Модула-2 является потомком Симулы, как и C++, но им не является Си), Java правильнее называть «троюродным племянником» C++, нежели «наследником». То же можно сказать о языке C#, хоть процент родственности с C++ у него несколько выше, чем у Java. Попыткой совмещения безопасности и скорости разработки, характерных для Java и C#, с возможностями C++ явился диалект Managed C++ (впоследствии — C++/CLI). Он разработан Microsoft в основном для переноса существующих проектов на C++ под платформу Microsoft.NET. Программы выполняются под управлением CLR и могут использовать весь массив библиотек .NET, но при этом накладывается ряд ограничений на использование возможностей C++, что фактически сводит C++ к C#. Данный диалект не получил широкого признания и используется в основном лишь для связывания библиотек, написанных на чистом C++, с C#-приложениями. Много усилий было приложено разработчиками Python и Lua для обеспечения использования этих языков программистами на C++, так что из всех языков, достаточно тесно связанных с ФП, именно они чаще всего отмечаются в совместном использовании с C++ в одном проекте. Наиболее значимыми точками соприкосновения C++ с ФП можно считать привязки разработанных на C++ библиотек wxWidgets и Qt с характерной для C++ идеологией к языкам Lisp, Haskell и Python (в большинстве случаев привязки к функциональным языкам делают для библиотек, написанных на Си или на других функциональных языках). Ещё одним языком, рассматриваемым как конкурент C++, стал Nemerle, являющийся результатом попытки совместить модель типизации Хиндли-Милнера и макроподмножество Common Lisp с языком C#[55]. В том же русле находится созданный Microsoft язык F# — диалект ML, адаптированный для среды .NET. Попыткой создать промышленную замену Си и C++ стал разработанный в корпорации Google в 2009 году язык программирования Go. Go — компактный, несложный по структуре императивный язык с Си-подобным синтаксисом, без препроцессора, со статической типизацией, строгим контролем типов, системой пакетов, автоматическим управлением памятью, некоторыми функциональными чертами, экономно построенной ООП-подсистемой без поддержки наследования реализации, но с интерфейсами и утиной типизацией, встроенной многопоточностью, основанной на сопрограммах и каналах (в духе Occam). Язык позиционируется как альтернатива C++, то есть, в первую очередь, средство групповой разработки высокоэффективных вычислительных систем большой сложности, в том числе распределённых, допускающее, при необходимости, низкоуровневое программирование. В одной нише с Си и C++ находится разработанный в 2010 году и поддерживаемый корпорацией Mozilla язык Rust, ориентированный на безопасное управление памятью без использования сборщика мусора. В частности, о планах частичной замены Си и C++ на Rust объявила в 2019 компания Microsoft[57].