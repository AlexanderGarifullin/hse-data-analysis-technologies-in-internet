C++ (читается си-плюс-плюс[2][3]) — компилируемый, статически типизированный язык программирования общего назначения. Поддерживает такие парадигмы программирования, как процедурное программирование, объектно-ориентированное программирование, обобщённое программирование. Так, язык Симула имеет такие возможности, которые были бы очень полезны для разработки большого программного обеспечения, но работает слишком медленно, а язык BCPL достаточно быстр, но слишком близок к языкам низкого уровня и не подходит для разработки большого программного обеспечения. Вспомнив опыт своей диссертации, Страуструп решил дополнить язык C (преемник BCPL) возможностями, имевшимися в языке Симула. Разрабатывая «Си с классами», Страуструп написал программу cfront — транслятор, перерабатывающий исходный код своего языка в исходный код простого Си. Новый язык неожиданно для автора приобрёл большую популярность среди коллег и вскоре Страуструп уже не мог лично поддерживать его, отвечая на тысячи вопросов. К 1983 году в язык были добавлены новые возможности, такие как виртуальные функции, перегрузка функций и операторов, ссылки, константы, пользовательский контроль над управлением свободной памятью, улучшенная проверка типов и новый стиль комментариев (//). Получившийся язык уже перестал быть просто дополненной версией классического C и был переименован из C с классами в «C++». До начала официальной стандартизации язык развивался в основном силами Страуструпа в ответ на запросы программистского сообщества. Одна из групп, разрабатывающих язык C++ и направляющих комитету по стандартизации C++ предложения по его улучшению — это Boost, которая занимается, в том числе, совершенствованием возможностей языка путём добавления в него особенностей метапрограммирования. Никто не обладает правами на язык C++, он является свободным. Некоторые из них:

Получить универсальный язык со статическими типами данных, эффективностью и переносимостью языка C.
Непосредственно и всесторонне поддерживать множество стилей программирования, в том числе процедурное программирование, абстракцию данных, объектно-ориентированное программирование и обобщённое программирование. Первое время язык развивался вне формальных рамок, спонтанно, по мере встававших перед ним задач. Эти номера версий кросс-компилятора распространялись и на сам язык, но применительно к настоящему времени речь о версиях языка C++ не ведут. Лишь в 1998 году язык стал стандартизированным. C++ поддерживает как комментарии в стиле C (/* комментарий */), так и однострочные (// вся оставшаяся часть строки является комментарием), где // обозначает начало комментария, а ближайший последующий символ новой строки, который не предварён символом \ (либо эквивалентным ему обозначением ? volatile используется в описании переменных и информирует компилятор, что значение данной переменной может быть изменено способом, который компилятор не в состоянии отследить. Типы C++ практически полностью повторяют типы данных в C:

символьные: char, wchar_t, char16_t и char32_t, в стандарте C++11 и char8_t в стандарте C++20);
целочисленные знаковые: signed char, short int, int, long int (и long long, в стандарте C++11);
целочисленные беззнаковые: unsigned char, unsigned short int, unsigned int, unsigned long int (и unsigned long long, в стандарте C++11);
с плавающей точкой: float, double, long double;
логический: bool, имеющий значения либо true, либо false. В стандарте C++ под классом (class) подразумевается пользовательский тип, объявленный с использованием одного из ключевых слов class, struct или union, под структурой (structure) подразумевается класс, определённый через ключевое слово struct, и под объединением (union) подразумевается класс, определённый через ключевое слово union. Наследование от каждого класса может быть публичным, защищённым или закрытым:

Доступ члена базового класса/режим наследования	private-член	protected-член	public-член
private-наследование	недоступен	private	private
protected-наследование	недоступен	protected	protected
public-наследование	недоступен	protected	public
По умолчанию базовый класс наследуется как private. Если один класс-предок наследуется несколько раз (это возможно, если он является предком нескольких базовых классов создаваемого класса), то экземпляры класса-потомка будет включать столько же подэкземпляров данного класса-предка. При наследовании базовый класс может объявляться виртуальным; на все виртуальные вхождения класса-предка в дерево наследования класса-потомка в потомке создаётся только один подэкземпляр. Полиморфным в C++ является тип, имеющий хотя бы один виртуальный метод. Пример иерархии:

class Figure
{
public:
    virtual void Draw() = 0; // чистый виртуальный метод
    virtual ~Figure();       // при наличии хотя бы одного виртуального метода деструктор следует сделать виртуальным
};

class Square : public Figure
{
public:
    void Draw() override;
};

class Circle : public Figure
{
public:
    void Draw() override;
};
Здесь класс Figure является абстрактным (и, даже, интерфейсным), так как метод Draw не определён. Доступ	private	protected	public
Сам класс	да	да	да
Друзья	да	да	да
Наследники	нет	да	да
Извне	нет	нет	да
Проверка доступа происходит во время компиляции, попытка обращения к недоступному члену класса вызовет ошибку компиляции. Если класс A объявляет другом класс B, то он не становится автоматически другом для B. Для этого должно существовать явное объявление дружественности A в классе B.
Дружественность не наследуется. Если A объявляет класс B своим другом, то потомки B не становятся автоматически друзьями A. Для этого каждый из них должен быть объявлен другом A в явной форме. Если класс A объявляет B другом, то B не становится автоматически другом для классов-потомков A. Каждый потомок, если это нужно, должен объявить B своим другом самостоятельно. Специальные функции
Класс по умолчанию может иметь шесть специальных функций: конструктор по умолчанию, конструктор копирования, конструктор перемещения, деструктор, оператор присваивания копированием, оператор присваивания перемещением. class Array {
public:
	Array() = default; // компилятор создаст конструктор по умолчанию сам
	Array(size_t _len) :
			len(_len) {
		val = new double[_len];
	}
	Array(const Array & a) = delete;  // конструктор копирования явно удалён
	Array(Array && a); // конструктор перемещения
	~Array() {
		delete[] val;
	}
	Array& operator=(const Array& rhs); // оператор присваивания копированием
	Array& operator=(Array&& rhs); // оператор присваивания перемещением
	double& operator[](size_t i) {
		return val[i];
	}
	const double& operator[](size_t i) const {
		return val[i];
	}

protected:
	std::size_t len = 0; // инициализация поля
	double* val {nullptr};
};
Конструктор вызывается для инициализации объекта (соответствующего типа) при его создании, а деструктор — для уничтожения объекта. Класс может иметь несколько конструкторов, но деструктор может иметь только один. Например, предыдущий класс мог бы реализовывать массив для любого типа данных:

template <typename T>
class Array {
    ...
    T& operator[](size_t i) {
		return val[i];
	}
protected:
	std::size_t len {0}; // инициализация поля
	T* val {nullptr};
};
Стандартная библиотека
Основная статья: Стандартная библиотека C++
Общая структура
Стандартная библиотека C++ включает в себя набор средств, которые должны быть доступны для любой реализации языка, чтобы обеспечить программистам удобное пользование языковыми средствами и создать базу для разработки как прикладных приложений самого широкого спектра, так и специализированных библиотек. Стандарт языка не называет её «STL», так как эта библиотека стала неотъемлемой частью языка, однако многие люди до сих пор используют это название, чтобы отличать её от остальной части стандартной библиотеки (потоки ввода-вывода (iostream), подраздел C и другие). Отличия от Си
Совместимость с Си
Основная статья: Несовместимость Си и C++
Выбор именно C в качестве базы для создания нового языка программирования объясняется тем, что язык C:
является многоцелевым, лаконичным и относительно низкоуровневым языком;
подходит для решения большинства системных задач;
исполняется везде и на всём;
стыкуется со средой программирования UNIX. Раздел 1.6[16]
Несмотря на ряд известных недостатков языка Си, Страуструп пошёл на его использование в качестве основы, так как «в Си есть свои проблемы, но их имел бы и разработанный с нуля язык, а проблемы C нам известны». Кроме того, это позволило быстро получить прототип компилятора (cfront), который лишь выполнял трансляцию добавленных синтаксических элементов в оригинальный язык Си. Новые возможности
Логотип Викиучебника	Имеется викиучебник по теме «Си++»
Новые возможности C++ включают объявления в виде выражений, преобразования типов в виде функций, операторы new и delete, тип bool, ссылки, расширенное понятие константности, подставляемые функции, аргументы по умолчанию, переопределения, пространства имён, классы (включая и все связанные с классами возможности, такие как наследование, функции-члены, виртуальные функции, абстрактные классы и конструкторы), переопределения операторов, шаблоны, оператор ::, обработку исключений, динамическую идентификацию и многое другое. Существует и такой верный для C код, который неверен для C++. Так происходит из-за того, что символьные константы в C (например, 'a') имеют тип int, а в C++ — тип char, а размеры этих типов обычно различаются. В целом C++ спроектирован и развивается как мультипарадигменный язык, впитывающий в себя различные методы и технологии программирования, но реализующий их на платформе, обеспечивающей высокую техническую эффективность. Поэтому в будущем не исключено добавление в язык средств функционального программирования, автоматической сборки мусора и других отсутствующих в нём сейчас механизмов. Для применения в шаблонах, там, где затруднительно указать конкретный тип переменной, введены два новых механизма: переменные типа auto и описание decltype. Добавлен необязательный модификатор override, который употребляется в объявлении метода, замещающего виртуальный метод родительского класса. C++ и Ада
Язык Ада близок к C++ по набору возможностей и по сферам применения: это компилируемый структурный язык с Симула-подобным объектно-ориентированным дополнением (та же модель «Алгол с классами», что и в C++), статической типизацией, средствами обобщённого программирования, предназначенный для разработки крупных и сложных программных систем. Ада имеет встроенную в язык модульность и стандартизованную систему раздельной компиляции, тогда как C++ применяет включение текстовых файлов и внешние средства управления компиляцией и сборкой. C++ и Java
Java не может считаться в полной мере заменой C++, она создана как безопасный язык с низким порогом вхождения для разработки прикладных пользовательских приложений с высокими показателями портируемости[30] и принципиально непригодна для некоторых типов приложений, которые разрабатываются на C++. В низкоуровневом программировании значительная часть новых возможностей C++ оказывается неприменимой из-за увеличения накладных расходов: виртуальные функции требуют динамического вычисления реального адреса (RVA), шаблоны приводят к раздуванию кода и ухудшению возможностей оптимизации, библиотека времени исполнения (RTL) очень велика, а отказ от неё лишает большинства возможностей C++ (хотя бы из-за недоступности операций new/delete). Критика
О критике C++ в целом
Чаще всего критики не противопоставляют C++ какой-либо другой конкретный язык, а утверждают, что отказ от использования единственного языка, имеющего многочисленные недостатки, в пользу декомпозиции проекта на подзадачи, решаемые на различных, наиболее подходящих для них, языках, делает разработку существенно менее трудоёмкой при одновременном повышении показателей качества программирования[35][36]. Этот язык почти не пересекается с самим C++, из-за чего потенциал роста сложности абстракций оказывается ограниченным. Программы, использующие шаблоны C++, имеют крайне низкие показатели понимаемости и тестируемости, а само разворачивание шаблонов порождает неэффективный код, так как язык шаблонов не предоставляет никаких средств для оптимизации (см. Функциональное программирование
Явная поддержка функционального программирования присутствует только в стандарте C++0x, ранее пробел устранялся библиотеками (Loki, Boost), использующими язык шаблонов, но их качество значительно уступают решениям, встроенным в функциональные языки[пояснения 1], как и качеству реализаций возможностей C++ (таких как ООП) посредством функциональных языков. Это резко повышает риск ошибок, тем более что вводить новый синтаксис и изменять существующий (например, создавать новые операторы или менять приоритеты или ассоциативность) нельзя, хотя синтаксис стандартных операторов C++ адекватен семантике далеко не всех типов, которые может потребоваться ввести в программу. Другим решением могла бы быть стандартизованная ещё в 1998 году возможность экспорта шаблонов, но она доступна далеко не во всех компиляторах, так как её трудно реализовать[48][49][мнения 4] и для импорта библиотек шаблонов C++ в языки с существенно отличной от C++ семантикой она всё равно была бы бесполезна. Результативность
Соотнесение факторов результативности с затратами на разработку, а также общую культивируемую в сообществе программистов дисциплину и культуру программирования важно принимать во внимание заказчикам, выбирающим язык С++ (и, соответственно, предпочитающим этот язык разработчикам) для реализации задуманных ими проектов, а также людям, начинающим изучать программирование, особенно с намерением программировать для собственных нужд. Качество и культура программирования
Принцип C++ «не навязывать „хороший“ стиль программирования» противоречит промышленному подходу к программированию, в котором ведущую роль играют качество программного обеспечения и возможность сопровождения кода не только автором, и для которого предпочтительны языки, сводящие к минимуму влияние человеческого фактора, то есть как раз «навязывающие „хороший“ стиль программирования», хотя такие языки и могут иметь более высокий порог вхождения. В частности, Линус Торвальдс говорит, что использует положительное мнение кандидатов о C++ в качестве критерия отсева[мнения 3]:
C++ — кошмарный язык. — Линус Торвальдс,[33]
Исправление исправного
Непрерывная эволюция языка побуждает (а порой вынуждает) программистов раз за разом изменять уже отлаженный код — это не только удорожает разработку, но и несёт риск внедрения в отлаженный код новых ошибок. В частности, хотя изначально обратная совместимость с Си была одним из базовых принципов C++, с 1999 года Си перестал быть подмножеством C++, так что отлаженный код на Си уже не может использоваться в проекте на C++ без изменений. По мнению Эрика Реймонда, это делает язык сам по себе почвой для личного самоутверждения программистов, превращения процесса разработки в самоцель:

Программисты — это зачастую яркие люди, которые гордятся … своей способностью справляться со сложностями и ловко обращаться с абстракциями. — Ф. Брукс, Мифический человеко-месяц
Влияние и альтернативы
Единственным прямым потомком C++ является язык D, задуманный как переработка C++ для устранения наиболее очевидных его проблем. Авторы отказались от совместимости с Си, сохранив синтаксис и многие базовые принципы C++ и введя в язык возможности, характерные для новых языков. Одной из первых альтернатив C++ в прикладном программировании стал язык Java. В том же русле находится созданный Microsoft язык F# — диалект ML, адаптированный для среды .NET. Попыткой создать промышленную замену Си и C++ стал разработанный в корпорации Google в 2009 году язык программирования Go. Go — компактный, несложный по структуре императивный язык с Си-подобным синтаксисом, без препроцессора, со статической типизацией, строгим контролем типов, системой пакетов, автоматическим управлением памятью, некоторыми функциональными чертами, экономно построенной ООП-подсистемой без поддержки наследования реализации, но с интерфейсами и утиной типизацией, встроенной многопоточностью, основанной на сопрограммах и каналах (в духе Occam). Язык позиционируется как альтернатива C++, то есть, в первую очередь, средство групповой разработки высокоэффективных вычислительных систем большой сложности, в том числе распределённых, допускающее, при необходимости, низкоуровневое программирование. В одной нише с Си и C++ находится разработанный в 2010 году и поддерживаемый корпорацией Mozilla язык Rust, ориентированный на безопасное управление памятью без использования сборщика мусора.